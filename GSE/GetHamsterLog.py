#!/usr/local/bin/python3
import serial, sys, argparse, time

##
## @brief      Populate the argparse parser with its argument format
##
## @param      parser  pre-instatiated argparse parser
##
## @return     the populated parser
##
def addargs(parser):
	parser.add_argument('port',
											help='Device file or COM port to which the HAMSTER is attached')
	parser.add_argument('-o', '--output_file', default='hamster.log',
											help='Name of the binary file to be generated by this program on your hard drive.')
	parser.add_argument('-b', '--baud', default=115200,
											help='Baud rate for serial comm with the HAMSTER (sending the dump command)')
	parser.add_argument('-d', '--dump-baud', help='Baud rate for receiving the actual dump data')
	parser.add_argument('-f', '--flight', action='store_true',
											help='If this flag is passed, the script will expect to interact with \
												  the HAMSTER FSW, starting in state STANDBY. Otherwise, it will \
												  expect to interact with the FlashLog test suite.')
	return parser

######### MAIN

def main():
	parser = argparse.ArgumentParser(description='This program grabs a binary dump from the FlashLog. To use it,\
				  you must first flash the FlashLog Test Suite to the HAMSTER using the `flash-test_flash` make target.\
				  If the output of this program is a garbage binary file, you probably aren\'t using the right\
				  baud rate. ')
	addargs(parser)
	args = parser.parse_args()

	# 2 second read timeout
	with serial.Serial(args.port, args.baud, timeout=2) as ser, open(args.output_file, 'wb') as ofile:
		bytes_received = 0
		time.sleep(2)
		try:
			if args.flight:
				print('Expecting to interact with the HAMSTER FSW, currently in state STANDBY.')
				print('Initiating hex dump...')
				ser.write('dump\n'.encode('ascii')) #dump command is valid from STANDBY state

			else:
				print('Expecting to interact with the FlashLog Test Suite')
                
                # program will have been reset when the serial port was opened
                
				print('Initiating binary dump...')
				ser.write('13\n'.encode('ascii')) #bindump is test #13

			if not args.dump_baud:
				if args.flight:
					# Hex dump runs at normal baud rate
					args.dump_baud = args.baud
				else:
					# Bin dump runs at faster rate
					args.dump_baud = 921600

			ser.flushOutput()
			time.sleep(.05) # wait a few ms for the previous write to go through (can't find another way than this)
			ser.baudrate = args.dump_baud

			READ_BLOCK_SIZE = 256

			# then just read the serial line forever until it stops sending.
			last_print_bytes = 0
			last_print_time = time.time()

			byte = ser.read(READ_BLOCK_SIZE)
			while len(byte) > 0:

				bytes_received = bytes_received + len(byte)
				if time.time() - last_print_time >= 1:

					# calc speed in kiB/s
					speed = ((bytes_received - last_print_bytes) / 1024) / (time.time() - last_print_time)
					last_print_time = time.time()
					last_print_bytes = bytes_received

					print('\r{} bytes received, speed = {:.2f}kiB/s.\t'.format(bytes_received, speed), end='')
				ofile.write(byte)
				byte = ser.read(READ_BLOCK_SIZE)
		except KeyboardInterrupt:
			#if we ctrl+c out of the progarm, stop the MBED running
			print('\nHalting MBED program execution (will only work if connected by USB)...')
			ser.send_break()

		print('{} chars written to "{}".'.format(bytes_received, args.output_file))

if __name__ == '__main__':
	sys.exit(main())
